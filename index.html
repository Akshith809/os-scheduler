<!--
Project: OS Scheduler Visualizer (Standalone Web App)
Filename: OS_Scheduler_Visualizer_Frontend.html
Author: Generated for student (will need to include your name/roll number before submission)

README / One-Page Execution Guide (visible on opening the page under the "README & Guide" tab):
- Overview: Interactive, client-side visualization of CPU Scheduling Algorithms (FCFS, SJF, Priority, Round Robin)
- Tech stack: HTML5, CSS3, JavaScript (ES6), Canvas API
- How to run: Save this file as index.html (or any .html) and open with any modern browser (Chrome >= v80, Firefox >= v78, Edge Chromium, Safari). No server required.
- UI Guide: Use the "Processes" panel to add/remove processes. Provide Process ID (auto if blank), Arrival Time, Burst Time, Priority (for Priority scheduling). Choose algorithm from dropdown. For RR, set Quantum. Use Play/Pause/Step Forward/Step Back controls and the timeline scrubber to jump between steps.
- Animation features: Canvas Gantt chart shows active CPU segments; left side visualizes ready queue as animated cards; colors indicate running/completed/waiting.
- Export: "Export Screenshot" saves the canvas view as PNG. "Export Trace" downloads a JSON with step-by-step trace.
- Browser requirements: Works fully offline in any modern desktop browser. Mobile layout supported but best on tablet/desktop.

Deliverables included in this single file for VTOP submission:
1) Complete Source Code (HTML/CSS/JS) - this file
2) One-Page Execution Guide - included in the README tab within the app
3) Demo: run locally; screenshots/exportable trace available

Notes on uniqueness: 
- Implements step-backwards (undo) using full state history so students can move forward/back one step reliably.
- Interactive timeline scrubber and per-step detailed stats display.
- Exports execution trace and screenshot for submission.

Academic honesty: Use as base and personalize names/comments before submission.
-->

<!--
Project: OS Scheduler Visualizer – Digital Assessment 1
Course Code: BCSE303L | Course Name: Operating Systems
Student Name: Akshith Chawla
Reg. No: VL2025260101320/21
Semester: Fall 2025–2026
Submission Date: 03–11–2025
-->

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>OS Scheduler Visualizer — CPU Scheduling</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#0ea5ff;--muted:#94a3b8;--good:#10b981;--danger:#ef4444}
    *{box-sizing:border-box;font-family:Inter, system-ui, Arial, sans-serif}
    body{margin:0;background:linear-gradient(180deg,#071029 0%,#051026 100%);color:#e6eef6}
    header{padding:16px 20px;display:flex;align-items:center;gap:16px;border-bottom:1px solid rgba(255,255,255,0.03)}
    h1{font-size:18px;margin:0}
    main{display:grid;grid-template-columns:360px 1fr;gap:18px;padding:18px}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .controls{display:flex;gap:8px;flex-wrap:wrap}
    label{display:block;font-size:12px;color:var(--muted);margin-bottom:6px}
    input[type=number], input[type=text], select{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:inherit}
    button{background:var(--accent);border:none;padding:8px 10px;border-radius:8px;color:#022;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    table{width:100%;border-collapse:collapse;margin-top:8px}
    td,th{padding:6px;font-size:13px}
    .small{font-size:12px;color:var(--muted)}
    canvas{background:#071020;border-radius:8px;width:100%;height:320px}
    .stats{display:flex;gap:6px;flex-wrap:wrap;margin-top:8px}
    .stat{padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);min-width:120px}
    .tabs{display:flex;gap:8px;margin-bottom:8px}
    .tab{padding:8px 10px;border-radius:8px;background:transparent;border:1px solid rgba(255,255,255,0.03);cursor:pointer}
    .tab.active{background:linear-gradient(90deg,var(--accent),#7dd3fc);color:#012}
    .footer{padding:12px;border-top:1px solid rgba(255,255,255,0.02);font-size:13px;color:var(--muted)}
    .queue{display:flex;gap:8px;align-items:center;overflow-x:auto;padding:8px}
    .proc{min-width:80px;padding:8px;border-radius:10px;background:rgba(255,255,255,0.02);text-align:center}
    .proc.running{box-shadow:0 6px 18px rgba(14,165,255,0.12);border:1px solid rgba(14,165,255,0.18)}
    .proc.completed{opacity:0.4;text-decoration:line-through}
    .left-col{height:calc(100vh - 140px);overflow:auto}
    .right-col{display:flex;flex-direction:column;gap:12px;height:calc(100vh - 140px);}
    .gantt-wrap{padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border-radius:10px}
    .timeline{width:100%}
    .file-actions{display:flex;gap:8px}
    footer small{color:var(--muted)}
    @media(max-width:900px){main{grid-template-columns:1fr;}
      .left-col{height:auto}
      canvas{height:240px}}
  </style>
</head>
<body>
  <header>
    <img src="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='36' height='36' viewBox='0 0 24 24'><rect width='24' height='24' rx='4' fill='%2307233b'/><path d='M4 12h16' stroke='%237dd3fc' stroke-width='1.5' stroke-linecap='round'/><path d='M12 4v16' stroke='%237dd3fc' stroke-width='1.5' stroke-linecap='round'/></svg>" alt="logo" style="width:36px;height:36px;border-radius:8px;margin-right:6px;"/>
    <div>
      <h1>OS Scheduler Visualizer — CPU Scheduling</h1>
      <div class="small">Algorithms: FCFS, SJF (non-preemptive), Priority (non-preemptive), Round Robin — client-side, exportable traces</div>
    </div>
  </header>
  <main>
    <div class="panel left-col">
      <div class="tabs">
        <button class="tab active" data-tab="ui">UI & Processes</button>
        <button class="tab" data-tab="readme">README & Guide</button>
      </div>

      <div id="tab-ui">
        <div style="display:flex;gap:8px;margin-bottom:10px;align-items:flex-end">
          <div style="flex:1">
            <label>Algorithm</label>
            <select id="algoSelect">
              <option value="FCFS">FCFS (First Come First Serve)</option>
              <option value="SJF">SJF (Shortest Job First) — Non-preemptive</option>
              <option value="PRIORITY">Priority — Non-preemptive (lower number = higher priority)</option>
              <option value="RR">Round Robin (Quantum)</option>
            </select>
          </div>
          <div style="width:140px">
            <label>Quantum (for RR)</label>
            <input id="quantum" type="number" min="1" value="4" />
          </div>
        </div>

        <div style="display:flex;gap:8px;align-items:flex-start">
          <div style="flex:1">
            <label>Add Process</label>
            <div style="display:flex;gap:6px">
              <input id="pidInput" type="text" placeholder="PID (auto)" />
              <input id="arrivalInput" type="number" min="0" placeholder="Arrival" />
              <input id="burstInput" type="number" min="1" placeholder="Burst" />
              <input id="prioInput" type="number" min="0" placeholder="Priority" />
              <button id="addProcBtn">Add</button>
            </div>

            <table id="procTable" style="margin-top:10px;background:transparent">
              <thead><tr><th>PID</th><th>Arr</th><th>Burst</th><th>Prio</th><th></th></tr></thead>
              <tbody></tbody>
            </table>
          </div>

          <div style="width:160px">
            <label>Controls</label>
            <div class="controls">
              <button id="playBtn">Play</button>
              <button id="pauseBtn" class="ghost">Pause</button>
              <button id="stepF">Step ▶</button>
              <button id="stepB" class="ghost">◀ Step</button>
            </div>

            <label style="margin-top:10px">Speed</label>
            <input id="speed" type="range" min="0.25" max="3" step="0.25" value="1" />

            <div style="margin-top:10px" class="file-actions">
              <button id="exportPNG">Export Screenshot</button>
              <button id="exportJSON" class="ghost">Export Trace</button>
            </div>
          </div>
        </div>

        <div style="margin-top:10px">
          <label>Ready Queue (visual)</label>
          <div id="readyQueue" class="queue"></div>
        </div>

        <div style="margin-top:12px">
          <label>Statistics</label>
          <div class="stats" id="statsBox">
            <div class="stat">Avg Waiting: <span id="avgWait">-</span></div>
            <div class="stat">Avg Turnaround: <span id="avgTurn">-</span></div>
            <div class="stat">Completion Time: <span id="compTime">-</span></div>
            <div class="stat">Context Switches: <span id="ctx">0</span></div>
          </div>
        </div>

      </div>

      <div id="tab-readme" style="display:none">
        <h3>One-Page Execution Guide</h3>
        <p class="small">Follow these steps to run and submit:</p>
        <ol>
          <li>Open this HTML file in a browser (no server needed).</li>
          <li>Add processes with arrival and burst time — leave PID blank to auto-generate.</li>
          <li>Select algorithm and (for RR) set quantum.</li>
          <li>Use Play/Pause or Step controls to animate execution. Use the timeline on the right to jump between steps.
          </li>
          <li>Export screenshot and trace for VTOP submission.</li>
        </ol>
        <h4>Color coding</h4>
        <ul>
          <li>Blue: Running process</li>
          <li>Gray: Waiting/ready</li>
          <li>Dim: Completed</li>
        </ul>
        <h4>Browser & Files</h4>
        <p class="small">Tested on Chrome/Firefox/Edge. For submission, attach this HTML, exported trace JSON and a screenshot.</p>
      </div>

      <div class="footer">
        <small>Tip: Add 4–6 processes to clearly see scheduling differences. Use Step Back to learn how waiting time changes.</small>
      </div>
    </div>

    <div class="right-col">
      <div class="panel gantt-wrap">
        <canvas id="ganttCanvas" width="1200" height="320"></canvas>
        <input id="timeline" class="timeline" type="range" min="0" max="0" value="0" />
      </div>

      <div class="panel">
        <h3 style="margin:0 0 8px 0">Execution Trace</h3>
        <div id="traceLog" style="height:140px;overflow:auto;background:transparent;padding:8px;border-radius:8px;">No trace yet</div>
      </div>

      <div class="panel">
        <h3 style="margin:0 0 8px 0">Process Table & Results</h3>
        <div id="resultsWrap">No runs yet</div>
      </div>
    </div>
  </main>

  <footer style="padding:8px 18px;display:flex;justify-content:space-between;align-items:center">
    <div class="small">Prepared for BCSE303L — Digital Assessment 1 (Fall 2025-2026) — CPU Scheduling Visualizer</div>
    <div class="small">Version 1.0 — Client-only</div>
  </footer>

<script>
// ------------------------- Data Models & Utilities -------------------------
class Proc {
  constructor(pid, arrival, burst, priority=0){
    this.pid = pid;
    this.arrival = Number(arrival);
    this.burst = Number(burst);
    this.priority = Number(priority);
    this.remaining = Number(burst);
    this.startTimes = [];
    this.finishTime = null;
  }
}

function uid(prefix='P'){ return prefix + Math.floor(Math.random()*9000+1000)}

// ------------------------- Scheduler Implementations -------------------------
// Each algorithm returns a trace: [{timeStart, timeEnd, pid, action}] and per-process stats

function scheduleFCFS(processes){
  // sort by arrival then by PID
  let time=0; let trace=[]; let completed=0; let procs = processes.map(p=>({...p}));
  procs.sort((a,b)=>a.arrival - b.arrival || a.pid.localeCompare(b.pid));
  for(let p of procs){
    if(time < p.arrival) time = p.arrival;
    trace.push({t0:time,t1:time + p.burst, pid:p.pid});
    p.start = time; p.finish = time + p.burst; time += p.burst; completed++;
  }
  return {trace, time, procs};
}

function scheduleSJF(processes){
  // non-preemptive SJF using arrival
  let time=0; let trace=[]; let N=processes.length;
  let procs = processes.map(p=>({...p}));
  let done=0; let ready=[];
  while(done < N){
    // push arrivals
    for(let p of procs) if(!p._added && p.arrival <= time){ p._added=true; ready.push(p); }
    if(ready.length===0){
      time = Math.min(...procs.filter(x=>!x._added).map(x=>x.arrival));
      for(let p of procs) if(!p._added && p.arrival <= time){ p._added=true; ready.push(p); }
    }
    ready.sort((a,b)=>a.burst - b.burst || a.arrival - b.arrival);
    let cur = ready.shift();
    trace.push({t0:time,t1:time + cur.burst, pid:cur.pid});
    cur.start = time; cur.finish = time + cur.burst; time += cur.burst; done++;
  }
  return {trace, time, procs};
}

function schedulePriority(processes){
  // non-preemptive priority: lower number -> higher priority
  let time=0; let trace=[]; let N=processes.length; let procs = processes.map(p=>({...p})); let ready=[]; let done=0;
  while(done<N){
    for(let p of procs) if(!p._added && p.arrival <= time){ p._added=true; ready.push(p); }
    if(ready.length===0){
      time = Math.min(...procs.filter(x=>!x._added).map(x=>x.arrival));
      for(let p of procs) if(!p._added && p.arrival <= time){ p._added=true; ready.push(p); }
    }
    ready.sort((a,b)=>a.priority - b.priority || a.arrival - b.arrival);
    let cur = ready.shift();
    trace.push({t0:time,t1:time + cur.burst, pid:cur.pid});
    cur.start=time; cur.finish=time+cur.burst; time+=cur.burst; done++;
  }
  return {trace, time, procs};
}

function scheduleRR(processes, quantum=4){
  let time=0; let trace=[]; let queue=[]; let procs = processes.map(p=>({...p, remaining: p.burst}));
  // sort arrivals
  procs.sort((a,b)=>a.arrival - b.arrival);
  let idx=0; while(true){
    while(idx<procs.length && procs[idx].arrival <= time){ queue.push(procs[idx]); idx++; }
    if(queue.length===0){
      if(idx>=procs.length) break; time = procs[idx].arrival; continue;
    }
    let cur = queue.shift();
    let exec = Math.min(cur.remaining, quantum);
    trace.push({t0:time, t1:time+exec, pid:cur.pid});
    cur.remaining -= exec; time += exec;
    // push new arrivals during execution
    while(idx<procs.length && procs[idx].arrival <= time){ queue.push(procs[idx]); idx++; }
    if(cur.remaining>0) queue.push(cur); else cur.finish = time;
  }
  return {trace, time, procs};
}

// ------------------------- Animator & History -------------------------
class Engine{
  constructor(canvas){
    this.canvas = canvas; this.ctx = canvas.getContext('2d');
    this.width = canvas.width; this.height = canvas.height;
    this.history = []; this.currentIndex = 0; this.playing = false; this.speed=1;
    this.trace = []; this.processes = []; this.colors = {};
  }
  setSpeed(s){ this.speed = s }
  prepare(processes, algo, quantum=4){
    // processes is array of Proc objects
    this.processes = processes.map(p=>({pid:p.pid, arrival:p.arrival, burst:p.burst, priority:p.priority}));
    // choose scheduler
    let res;
    if(algo==='FCFS') res = scheduleFCFS(this.processes);
    else if(algo==='SJF') res = scheduleSJF(this.processes);
    else if(algo==='PRIORITY') res = schedulePriority(this.processes);
    else res = scheduleRR(this.processes, quantum);
    // build detailed per-time step states and history
    this.trace = res.trace;
    // construct history frames where each frame corresponds to end of each trace segment
    this.history = [];
    let completed = new Set();
    for(let i=0;i<this.trace.length;i++){
      let seg = this.trace[i];
      completed.add(seg.pid);
      let frame = {
        step:i,
        time:seg.t1,
        running:seg.pid,
        completed:[...completed],
        segment:Object.assign({},seg)
      };
      this.history.push(frame);
    }
    if(this.history.length===0) this.history.push({step:0,time:0,running:null,completed:[]});
    this.currentIndex = 0;
    // assign colors
    this.colors = {};
    let palette = ['#60a5fa','#34d399','#f472b6','#f59e0b','#60f',' #fb7185'];
    let pids = [...new Set(this.processes.map(p=>p.pid))];
    pids.forEach((pid,i)=>this.colors[pid]=palette[i%palette.length]);
    this.render();
  }
  play(){ if(this.playing) return; this.playing=true; this._tick(); }
  pause(){ this.playing=false; }
  stepForward(){ if(this.currentIndex < this.history.length-1) this.currentIndex++; this.render(); }
  stepBack(){ if(this.currentIndex>0) this.currentIndex--; this.render(); }
  jumpTo(idx){ this.currentIndex = Math.max(0, Math.min(this.history.length-1, idx)); this.render(); }
  _tick(){ if(!this.playing) return; this.currentIndex++; if(this.currentIndex>=this.history.length){ this.currentIndex = this.history.length-1; this.playing=false; return; } this.render(); setTimeout(()=>this._tick(), 800/this.speed); }
  render(){
    const ctx = this.ctx; ctx.clearRect(0,0,this.width,this.height);
    // draw timeline baseline
    ctx.fillStyle = '#071026'; ctx.fillRect(0,0,this.width,this.height);
    // Draw trace as Gantt
    const pad = 20; const h = 40; const gap=8; const left=40; const right=40;
    // compute scale
    let totalEnd = Math.max(...this.trace.map(s=>s.t1), 10);
    const usable = this.width - left - right; const scale = usable / totalEnd;
    // draw segments
    for(let i=0;i<this.trace.length;i++){
      const s = this.trace[i]; const x = left + s.t0*scale; const w = Math.max(2,(s.t1 - s.t0)*scale);
      ctx.fillStyle = this.colors[s.pid] || '#7dd3fc';
      ctx.fillRect(x, pad + i*(h+gap), w, h);
      // pid label
      ctx.fillStyle = '#021226'; ctx.font='12px sans-serif'; ctx.fillText(s.pid, x+6, pad + i*(h+gap) + 24);
    }
    // highlight current segment
    const cur = this.history[this.currentIndex];
    if(cur){
      const seg = cur.segment; const x = left + seg.t0*scale; const w = Math.max(2,(seg.t1 - seg.t0)*scale);
      ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth=2; ctx.strokeRect(x-2, pad + cur.step*(h+gap)-2, w+4, h+4);
    }
    // draw time marks
    ctx.fillStyle='#94a3b8'; ctx.font='11px sans-serif'; for(let t=0;t<=totalEnd;t++){ let xx=left + t*scale; ctx.fillRect(xx, pad + this.trace.length*(h+gap)+6, 1,6); if(t%Math.ceil(Math.max(1,totalEnd/10))===0) ctx.fillText(t, xx-6, pad+this.trace.length*(h+gap)+22); }
    // show running process and ready queue
    const running = cur?cur.running:null;
    const readyEl = document.getElementById('readyQueue'); readyEl.innerHTML='';
    let orderedReady = this.processes.map(p=>p.pid);
    orderedReady.forEach(pid=>{
      const el = document.createElement('div'); el.className='proc'; if(pid===running) el.classList.add('running'); if((cur&&cur.completed.includes(pid))) el.classList.add('completed'); el.innerHTML=`<div style="font-weight:700">${pid}</div><div class="small">${this.processes.find(x=>x.pid===pid).burst}</div>`; readyEl.appendChild(el);
    });
    // update trace log & stats
    const log = document.getElementById('traceLog'); log.innerHTML='';
    for(let i=0;i<=this.currentIndex;i++){ const s = this.trace[i]; const d = document.createElement('div'); d.className='small'; d.textContent=`[${s.t0} — ${s.t1}] Process ${s.pid}`; log.appendChild(d);}    
    const avgWaitEl = document.getElementById('avgWait'); const avgTurnEl = document.getElementById('avgTurn'); const compEl = document.getElementById('compTime'); const ctxEl = document.getElementById('ctx');
    // compute sample stats: waiting & turnaround
    const ps = this.processes.map(p=>({pid:p.pid, arrival:p.arrival, burst:p.burst}));
    // for stats, compute from trace: for each pid, start = first t0 where pid appears, finish = last t1
    const map = {};
    for(const s of this.trace){ if(!map[s.pid]) map[s.pid]={start:s.t0,finish:s.t1}; else map[s.pid].finish = s.t1; }
    const waits = []; const turns=[];
    for(const p of ps){ if(map[p.pid]){ const comp = map[p.pid].finish; const tat = comp - p.arrival; const wt = tat - p.burst; waits.push(wt); turns.push(tat);} }
    function avg(arr){ if(arr.length===0) return '-'; return (arr.reduce((a,b)=>a+b,0)/arr.length).toFixed(2);}    
    avgWaitEl.textContent = avg(waits); avgTurnEl.textContent = avg(turns); compEl.textContent = (this.trace.length?Math.max(...this.trace.map(s=>s.t1)):0);
    ctxEl.textContent = this.trace.length>0?this.trace.length-1:0;
    // update timeline range
    const timeline = document.getElementById('timeline'); timeline.max = Math.max(0,this.history.length-1); timeline.value = this.currentIndex;
    // results table
    const resWrap = document.getElementById('resultsWrap');
    let html = '<table style="width:100%"><thead><tr><th>PID</th><th>Arrival</th><th>Burst</th><th>Start</th><th>Finish</th><th>Waiting</th><th>Turnaround</th></tr></thead><tbody>';
    for(const p of ps){ const m = map[p.pid]||{}; const start=m.start||'-'; const finish=m.finish||'-'; const tat = finish==='-'?'-':finish - p.arrival; const wt = tat==='-'?'-':tat - p.burst; html += `<tr><td>${p.pid}</td><td>${p.arrival}</td><td>${p.burst}</td><td>${start}</td><td>${finish}</td><td>${wt}</td><td>${tat}</td></tr>`; }
    html += '</tbody></table>';
    resWrap.innerHTML = html;
  }
}

// ------------------------- App wiring -------------------------
const canvas = document.getElementById('ganttCanvas'); const engine = new Engine(canvas);
// UI state
let processes = [];
function refreshProcTable(){ const tbody = document.querySelector('#procTable tbody'); tbody.innerHTML=''; processes.forEach((p,i)=>{ const tr=document.createElement('tr'); tr.innerHTML=`<td>${p.pid}</td><td>${p.arrival}</td><td>${p.burst}</td><td>${p.priority}</td><td><button data-i='${i}' class='ghost del'>Del</button></td>`; tbody.appendChild(tr); }); }

document.getElementById('addProcBtn').addEventListener('click', ()=>{
  let pid = document.getElementById('pidInput').value.trim() || uid('P');
  let arrival = document.getElementById('arrivalInput').value; let burst = document.getElementById('burstInput').value; let prio = document.getElementById('prioInput').value || 0;
  if(burst===''||arrival==='') { alert('Provide arrival and burst'); return; }
  processes.push(new Proc(pid, Number(arrival), Number(burst), Number(prio)));
  document.getElementById('pidInput').value=''; document.getElementById('arrivalInput').value=''; document.getElementById('burstInput').value=''; document.getElementById('prioInput').value='';
  refreshProcTable();
});

document.querySelector('#procTable tbody').addEventListener('click', (e)=>{ if(e.target.classList.contains('del')){ const i = Number(e.target.dataset.i); processes.splice(i,1); refreshProcTable(); } });

document.getElementById('playBtn').addEventListener('click', ()=>{ engine.play(); });
document.getElementById('pauseBtn').addEventListener('click', ()=>{ engine.pause(); });
document.getElementById('stepF').addEventListener('click', ()=>{ engine.stepForward(); });
document.getElementById('stepB').addEventListener('click', ()=>{ engine.stepBack(); });

document.getElementById('speed').addEventListener('input', (e)=>{ engine.setSpeed(Number(e.target.value)); });

document.getElementById('algoSelect').addEventListener('change', ()=>{ rebuild(); });
document.getElementById('quantum').addEventListener('change', ()=>{ rebuild(); });

function rebuild(){ if(processes.length===0) return; const algo=document.getElementById('algoSelect').value; const q=Number(document.getElementById('quantum').value); engine.prepare(processes.map(p=>({...p})), algo, q); }

document.getElementById('exportPNG').addEventListener('click', ()=>{
  const link=document.createElement('a'); link.href = canvas.toDataURL('image/png'); link.download='gantt_screenshot.png'; link.click();
});

document.getElementById('exportJSON').addEventListener('click', ()=>{
  const payload = {processes: processes.map(p=>({pid:p.pid,arrival:p.arrival,burst:p.burst,priority:p.priority})), trace: engine.trace};
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
  const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download='execution_trace.json'; a.click(); URL.revokeObjectURL(url);
});

// timeline input
document.getElementById('timeline').addEventListener('input', (e)=>{ const v = Number(e.target.value); engine.jumpTo(v); });

// initial demo processes
processes.push(new Proc('P1',0,5,2)); processes.push(new Proc('P2',1,3,1)); processes.push(new Proc('P3',2,8,3)); processes.push(new Proc('P4',3,6,2)); refreshProcTable(); rebuild();

// tabs behaviour
document.querySelectorAll('.tab').forEach(btn=>btn.addEventListener('click', ()=>{
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  btn.classList.add('active'); const tab=btn.dataset.tab; document.getElementById('tab-ui').style.display = tab==='ui'?'block':'none'; document.getElementById('tab-readme').style.display = tab==='readme'?'block':'none';
}));

// expose for console debugging
window.__OSViz = {engine, processes};
</script>
</body>
</html>

<footer>
    <p>Developed by <b>Akshith Chawla</b> (VL2025260101320/21)</p>
    <p>BCSE303L — Operating Systems | DA1 | Fall 2025–2026</p>
  </footer>